import fs from 'fs';
import path from 'path';

// --- HELPER: TS OBJECT FORMATTER ---
function formatAsTsObject(data: any): string {
    if (Array.isArray(data) && data.length === 0) return '';

    // 1. Generate standard JSON with indentation
    const jsonLines = JSON.stringify(data, null, 4).split('\n');

    // 2. Remove enclosing brackets if it's an array
    if (Array.isArray(data)) {
        // Remove first line if it is just "["
        if (jsonLines.length > 0 && jsonLines[0].trim() === '[') {
            jsonLines.shift();
        }
        // Remove last line if it is just "]"
        if (jsonLines.length > 0 && jsonLines[jsonLines.length - 1].trim() === ']') {
            jsonLines.pop();
        }
    }

    // 3. Process line-by-line to remove quotes from valid identifier keys
    const tsLines = jsonLines.map(line => {
        // Regex logic:
        // ^(\s*) -> capture indentation
        // "([a-zA-Z_]\w*)" -> capture key if it starts with letter/_ and contains only word chars
        // (\s*:) -> capture the colon separator
        return line.replace(/^(\s*)"([a-zA-Z_]\w*)"(\s*:)/, '$1$2$3');
    });

    return tsLines.join('\n');
}

// --- HELPER: ROBUST PARSER ---
function parseInputData(rawContent: string): any {
    if (!rawContent || rawContent.trim() === '') return [];

    // 1. Remove standard comments (Single line // and Multi-line /* */)
    const cleanContent = rawContent.replace(/("(?:[^"\\]|\\.)*")|(\/\/[^\n\r]*|\/\*[\s\S]*?\*\/)/g, (match, str) => {
        if (str) return str;
        return '';
    }).trim();

    // 2. Auto-fix: Wrap in brackets if needed (Handles the "No Bracket" format)
    let parseableContent = cleanContent;
    // If it doesn't start with '[', assume it's a list of objects and wrap it
    if (!parseableContent.startsWith('[') && parseableContent.includes('{')) {
        // We also check if commas are missing between objects (e.g. } {) and fix them
        // If the file was generated by this script, commas are already there, but this is safe.
        parseableContent = `[${parseableContent.replace(/}(\s*){/g, '}, $1{')}]`;
    }

    // 3. Parse using Function constructor (handles relaxed JSON)
    try {
        if (parseableContent === '[]' || !parseableContent) return [];

        const func = new Function(`return ${parseableContent};`);
        return func();
    } catch (e) {
        throw new Error(`Failed to parse data. Error: ${(e as Error).message}`);
    }
}

// --- VALIDATION & CLEANING FUNCTION ---
function cleanAndValidatePlan(raw: any): { valid: boolean; data: any; errors: string[] } {
    const errors: string[] = [];
    const clean = { ...raw };

    // 1. CLEAN ID
    if (clean.id) {
        clean.id = clean.id.toLowerCase().trim().replace(/\s+/g, '-');
    } else {
        errors.push(`Missing 'id'`);
    }

    // 2. STRUCTURE CHECKS
    if (clean.price === undefined) errors.push("Missing 'price'");
    if (clean.savings_annual === undefined) errors.push("Missing 'savings_annual'");

    if (!clean.identity) {
        errors.push("Missing 'identity' object");
    } else {
        if (!clean.identity.scheme_name) errors.push("Missing 'identity.scheme_name'");
        if (!clean.identity.plan_name) errors.push("Missing 'identity.plan_name'");
        if (!clean.identity.plan_type) errors.push("Missing 'identity.plan_type'");
    }

    if (!Array.isArray(clean.contributions) || clean.contributions.length === 0) {
        errors.push("Missing or empty 'contributions' array");
    }

    if (!clean.network_restriction) errors.push("Missing 'network_restriction'");
    if (!clean.network_details) errors.push("Missing 'network_details' object");
    if (!clean.coverage_rates) errors.push("Missing 'coverage_rates' object");
    if (!clean.limits) errors.push("Missing 'limits' object");
    if (!clean.defined_baskets) errors.push("Missing 'defined_baskets' object");
    if (clean.chronic_conditions === undefined) errors.push("Missing 'chronic_conditions'");
    if (!clean.procedure_copays) errors.push("Missing 'procedure_copays' object");
    if (!clean.gap_cover_rating) errors.push("Missing 'gap_cover_rating'");

    return {
        valid: errors.length === 0,
        data: clean,
        errors
    };
}

// --- MAIN EXECUTION ---
async function main() {
    const inputFile = process.argv[2];
    const outputFile = process.argv[3];

    if (!inputFile || !outputFile) {
        console.error("Usage: npx tsx scripts/validate-plans.ts <input_file> <output_file>");
        process.exit(1);
    }

    try {
        const absInput = path.resolve(inputFile);
        const absOutput = path.resolve(outputFile);

        // 1. READ NEW DATA
        console.log(`üìñ Reading new plans from: ${inputFile}`);
        const rawContent = fs.readFileSync(absInput, 'utf-8');
        const rawNewData = parseInputData(rawContent);

        if (!Array.isArray(rawNewData)) throw new Error("Input file must contain an array of plans.");

        // 2. READ EXISTING DATA (Merge Strategy)
        const planMap = new Map<string, any>();

        if (fs.existsSync(absOutput)) {
            console.log(`üìÇ Found existing file: ${outputFile}. Merging...`);
            try {
                const existingContent = fs.readFileSync(absOutput, 'utf-8');
                const existingData = parseInputData(existingContent);

                if (Array.isArray(existingData)) {
                    existingData.forEach(p => {
                        if (p.id) planMap.set(p.id, p);
                    });
                    console.log(`   - Loaded ${existingData.length} existing plans.`);
                }
            } catch (e) {
                console.warn(`   ‚ö†Ô∏è Warning: Could not parse existing output file. Overwriting completely. (${(e as Error).message})`);
            }
        }

        // 3. PROCESS & MERGE NEW DATA
        const cleanNewPlans = [];
        let errorCount = 0;

        for (let i = 0; i < rawNewData.length; i++) {
            const result = cleanAndValidatePlan(rawNewData[i]);

            if (result.valid) {
                // UPSERT: Overwrite if ID exists
                planMap.set(result.data.id, result.data);
                cleanNewPlans.push(result.data);
            } else {
                errorCount++;
                console.error(`\n‚ùå Error in Plan #${i + 1} (${result.data.id || 'Unknown ID'}):`);
                result.errors.forEach(e => console.error(`   - ${e}`));
            }
        }

        // 4. WRITE OUTPUT (WITHOUT ARRAY BRACKETS)
        const finalPlans = Array.from(planMap.values());
        const tsOutput = formatAsTsObject(finalPlans);

        fs.writeFileSync(absOutput, tsOutput);

        console.log(`\n‚úÖ Completed.`);
        console.log(`   - New Validated: ${cleanNewPlans.length}`);
        console.log(`   - Failed:        ${errorCount}`);
        console.log(`   - Total Saved:   ${finalPlans.length} (in ${outputFile})`);

    } catch (e) {
        console.error("Critical Error:", e);
        process.exit(1);
    }
}

main();